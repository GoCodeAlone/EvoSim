package main

import (
	"testing"
)

func TestPlayerEventSystem(t *testing.T) {
	// Create a simple world
	config := WorldConfig{
		Width:          50.0,
		Height:         50.0,
		NumPopulations: 0,
		PopulationSize: 5,
		GridWidth:      20,
		GridHeight:     20,
	}
	world := NewWorld(config)
	
	// Track events
	events := make([]map[string]interface{}, 0)
	eventCallback := func(eventType string, data map[string]interface{}) {
		event := make(map[string]interface{})
		event["type"] = eventType
		for k, v := range data {
			event[k] = v
		}
		events = append(events, event)
	}
	
	// Set up the callback
	world.PlayerEventsCallback = eventCallback
	
	// Create a test population
	testSpecies := "TestSpecies"
	popConfig := PopulationConfig{
		Name:             testSpecies,
		Species:          testSpecies,
		BaseTraits:       map[string]float64{"size": 0.0, "speed": 0.1},
		StartPos:         Position{X: 25, Y: 25},
		Spread:           5.0,
		Color:            "purple",
		BaseMutationRate: 0.1,
	}
	
	world.AddPopulation(popConfig)
	
	// Get the actual species name generated by the world (it might be modified)
	actualSpeciesName := ""
	for name := range world.Populations {
		actualSpeciesName = name
		break
	}
	
	if actualSpeciesName == "" {
		t.Fatal("No species was created")
	}
	
	// Initialize population counts for the first time
	world.checkPlayerSpeciesEvents()
	
	// Wait to ensure we have a baseline
	if len(world.PreviousPopulationCounts) == 0 {
		t.Error("PreviousPopulationCounts should be initialized")
	}
	
	initialCount := world.PreviousPopulationCounts[actualSpeciesName]
	if initialCount == 0 {
		t.Errorf("Initial population count should be greater than 0, got %d", initialCount)
	}
	
	// Simulate species extinction by killing all entities
	if population, exists := world.Populations[actualSpeciesName]; exists {
		for _, entity := range population.Entities {
			entity.IsAlive = false
		}
	} else {
		t.Fatalf("Population %s not found", actualSpeciesName)
	}
	
	// Check events after extinction
	world.checkPlayerSpeciesEvents()
	
	// Verify extinction event was triggered
	found := false
	for _, event := range events {
		if event["type"] == "species_extinct" && event["species_name"] == actualSpeciesName {
			found = true
			break
		}
	}
	
	if !found {
		t.Errorf("Expected species_extinct event for %s was not triggered. Events: %v", actualSpeciesName, events)
	}
}

func TestPlayerSpeciesExtinctionNotification(t *testing.T) {
	// Create web interface
	config := WorldConfig{
		Width:          30.0,
		Height:         30.0,
		NumPopulations: 0,
		PopulationSize: 3,
		GridWidth:      10,
		GridHeight:     10,
	}
	world := NewWorld(config)
	wi := NewWebInterface(world)
	
	// Test that callback is set up
	if world.PlayerEventsCallback == nil {
		t.Error("PlayerEventsCallback should be set up by WebInterface")
	}
	
	// Add a test player
	player, err := wi.playerManager.AddPlayer("test_player", "TestPlayer")
	if err != nil {
		t.Fatalf("Failed to add player: %v", err)
	}
	
	// Create a test species
	testSpecies := "TestExtinctSpecies"
	popConfig := PopulationConfig{
		Name:             testSpecies,
		Species:          testSpecies,
		BaseTraits:       map[string]float64{"size": 0.0, "speed": 0.1},
		StartPos:         Position{X: 15, Y: 15},
		Spread:           3.0,
		Color:            "purple",
		BaseMutationRate: 0.1,
	}
	
	world.AddPopulation(popConfig)
	
	// Get actual species name
	actualSpeciesName := ""
	for name := range world.Populations {
		actualSpeciesName = name
		break
	}
	
	err = wi.playerManager.AddPlayerSpecies(player.ID, actualSpeciesName)
	if err != nil {
		t.Fatalf("Failed to add species to player: %v", err)
	}
	
	// Initialize counts
	world.checkPlayerSpeciesEvents()
	
	// Verify player owns species
	if !wi.playerManager.CanPlayerControlSpecies(player.ID, actualSpeciesName) {
		t.Error("Player should be able to control their species")
	}
	
	// Simulate extinction
	if population, exists := world.Populations[actualSpeciesName]; exists {
		for _, entity := range population.Entities {
			entity.IsAlive = false
		}
	}
	
	// Manually call the extinction detection with a test callback
	eventDetected := false
	testCallback := func(eventType string, data map[string]interface{}) {
		if eventType == "species_extinct" && data["species_name"] == actualSpeciesName {
			// Manually mark as extinct since we don't have a websocket connection
			wi.playerManager.MarkSpeciesExtinct(actualSpeciesName)
			eventDetected = true
		}
	}
	
	// Temporarily replace the callback
	originalCallback := world.PlayerEventsCallback
	world.PlayerEventsCallback = testCallback
	
	// Check events - this should trigger our test callback
	world.checkPlayerSpeciesEvents()
	
	// Restore original callback
	world.PlayerEventsCallback = originalCallback
	
	if !eventDetected {
		t.Error("Extinction event was not detected")
	}
	
	// Verify species is marked as extinct in player manager
	if playerSpecies, exists := wi.playerManager.PlayerSpecies[actualSpeciesName]; exists {
		if !playerSpecies.IsExtinct {
			t.Error("Species should be marked as extinct in player manager")
		}
	}
}

func TestFindPotentialParentSpecies(t *testing.T) {
	config := WorldConfig{
		Width:          20.0,
		Height:         20.0,
		NumPopulations: 0,
		PopulationSize: 2,
		GridWidth:      5,
		GridHeight:     5,
	}
	world := NewWorld(config)
	
	// Add parent species
	parentSpecies := "Herbivore"
	popConfig := PopulationConfig{
		Name:             parentSpecies,
		Species:          parentSpecies,
		BaseTraits:       map[string]float64{"size": 0.0},
		StartPos:         Position{X: 10, Y: 10},
		Spread:           2.0,
		Color:            "green",
		BaseMutationRate: 0.1,
	}
	world.AddPopulation(popConfig)
	
	// Get the actual parent species name
	actualParentSpecies := ""
	for name := range world.Populations {
		actualParentSpecies = name
		break
	}
	
	if actualParentSpecies == "" {
		t.Fatal("No parent species was created")
	}
	
	// Test finding parent for subspecies
	tests := []struct {
		subspecies     string
		expectedParent string
	}{
		{actualParentSpecies + "Variant", actualParentSpecies},    // Clear variant
		{actualParentSpecies + "_A", actualParentSpecies},         // Clear subspecies
		{actualParentSpecies + "Plus", actualParentSpecies},       // Extended name
		{"CompletelyDifferent", ""},                               // No relation
		{"Herb", ""},                                              // Too short
	}
	
	for _, test := range tests {
		result := world.findPotentialParentSpecies(test.subspecies)
		if result != test.expectedParent {
			t.Errorf("For subspecies '%s', expected parent '%s', got '%s'", 
				test.subspecies, test.expectedParent, result)
		}
	}
}