<!DOCTYPE html>
<html>
<head>
    <title>EvoSim - 2.5D Isometric View</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            color: white;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #0f1527;
            cursor: pointer;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.4;
            max-width: 300px;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.4;
        }
        
        #detailsPanel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.3;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }
        
        .button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .button:hover {
            background: #45a049;
        }
        
        .entity-details {
            border-left: 3px solid #4CAF50;
            padding-left: 10px;
        }
        
        .plant-details {
            border-left: 3px solid #8BC34A;
            padding-left: 10px;
        }
        
        .dna-sequence {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            background: rgba(50, 50, 50, 0.5);
            padding: 5px;
            border-radius: 3px;
            margin: 5px 0;
            word-break: break-all;
        }
        
        .trait-bar {
            display: flex;
            align-items: center;
            margin: 2px 0;
        }
        
        .trait-name {
            width: 100px;
            font-size: 10px;
        }
        
        .trait-value {
            flex: 1;
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin: 0 5px;
            overflow: hidden;
        }
        
        .trait-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading EvoSim...</div>
    
    <canvas id="gameCanvas" width="1024" height="768"></canvas>
    
    <div id="ui">
        <h3>EvoSim 2.5D Isometric View</h3>
        <div>Camera: (<span id="cameraX">0</span>, <span id="cameraY">0</span>)</div>
        <div>Zoom: <span id="zoomLevel">1.0</span>x</div>
        <div>Entities: <span id="entityCount">0</span></div>
        <div>Plants: <span id="plantCount">0</span></div>
        <div>World Tick: <span id="worldTick">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
        <div>Terrain: <span id="terrainInfo">Loading...</span></div>
        <div>Geological Events: <span id="geoEvents">0</span></div>
    </div>
    
    <div id="controls">
        <h4>Controls</h4>
        <div>WASD / Arrow Keys - Move Camera</div>
        <div>Mouse Wheel - Zoom</div>
        <div>Left Click - Select Entity/Plant</div>
        <div>Space - Toggle Details</div>
        <div>R - Reset Camera</div>
        <button class="button" onclick="togglePause()">Pause/Resume</button>
        <button class="button" onclick="resetCamera()">Reset Camera</button>
        <button class="button" onclick="toggleDetails()">Toggle Details</button>
    </div>
    
    <div id="detailsPanel">
        <div id="detailsContent"></div>
    </div>

    <script>
        // Game state
        let gameState = {
            canvas: null,
            ctx: null,
            websocket: null,
            isometricData: null,
            camera: { x: 50, y: 50 },
            zoom: 1.0,
            selectedEntity: null,
            selectedPlant: null,
            showDetails: false,
            paused: false,
            lastUpdate: 0,
            fps: 0,
            frameCount: 0,
            lastFpsUpdate: 0,
            keys: {},
            mousePos: { x: 0, y: 0 },
            tileSize: { width: 64, height: 32 },
            elevationScale: 50, // Height multiplier for elevation rendering
            maxElevation: 1.0,  // Maximum elevation value for scaling
            minElevation: -0.5, // Minimum elevation value for scaling
            depthLayers: []     // For depth sorting
        };

        // Initialize the game
        function init() {
            gameState.canvas = document.getElementById('gameCanvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            // Setup event listeners
            setupEventListeners();
            
            // Connect to WebSocket
            connectWebSocket();
            
            // Start game loop
            gameLoop();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
        }

        // Setup event listeners
        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.key.toLowerCase()] = true;
                handleKeyDown(e);
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.key.toLowerCase()] = false;
            });
            
            // Mouse events
            gameState.canvas.addEventListener('click', handleMouseClick);
            gameState.canvas.addEventListener('mousemove', handleMouseMove);
            gameState.canvas.addEventListener('wheel', handleMouseWheel);
            
            // Prevent context menu
            gameState.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        // Connect to WebSocket for real-time data
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            gameState.websocket = new WebSocket(wsUrl);
            
            gameState.websocket.onopen = () => {
                console.log('WebSocket connected');
                // Request isometric view data
                requestIsometricData();
            };
            
            gameState.websocket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'isometric') {
                    gameState.isometricData = data.data;
                    updateUI();
                }
            };
            
            gameState.websocket.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                setTimeout(connectWebSocket, 1000);
            };
            
            gameState.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        // Request isometric data from server
        function requestIsometricData() {
            if (gameState.websocket && gameState.websocket.readyState === WebSocket.OPEN) {
                const request = {
                    type: 'get_isometric_data',
                    viewportX: Math.floor(gameState.camera.x),
                    viewportY: Math.floor(gameState.camera.y),
                    zoom: gameState.zoom,
                    maxTiles: 1000
                };
                gameState.websocket.send(JSON.stringify(request));
            }
        }

        // Main game loop
        function gameLoop() {
            const now = performance.now();
            
            // Update FPS counter
            gameState.frameCount++;
            if (now - gameState.lastFpsUpdate > 1000) {
                gameState.fps = Math.round(gameState.frameCount * 1000 / (now - gameState.lastFpsUpdate));
                gameState.frameCount = 0;
                gameState.lastFpsUpdate = now;
            }
            
            // Update game state
            update(now - gameState.lastUpdate);
            gameState.lastUpdate = now;
            
            // Render
            render();
            
            // Request isometric data periodically
            if (now % 500 < 16) { // Roughly every 500ms
                requestIsometricData();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Update game logic
        function update(deltaTime) {
            const moveSpeed = 2.0 * (deltaTime / 16); // Normalized to 60fps
            
            // Handle camera movement
            if (gameState.keys['w'] || gameState.keys['arrowup']) {
                gameState.camera.y -= moveSpeed / gameState.zoom;
            }
            if (gameState.keys['s'] || gameState.keys['arrowdown']) {
                gameState.camera.y += moveSpeed / gameState.zoom;
            }
            if (gameState.keys['a'] || gameState.keys['arrowleft']) {
                gameState.camera.x -= moveSpeed / gameState.zoom;
            }
            if (gameState.keys['d'] || gameState.keys['arrowright']) {
                gameState.camera.x += moveSpeed / gameState.zoom;
            }
            
            // Clamp camera to world bounds
            if (gameState.isometricData) {
                const worldInfo = gameState.isometricData.worldInfo;
                gameState.camera.x = Math.max(0, Math.min(worldInfo.width, gameState.camera.x));
                gameState.camera.y = Math.max(0, Math.min(worldInfo.height, gameState.camera.y));
            }
        }

        // Render the game with proper depth sorting and 2.5D effects
        function render() {
            const ctx = gameState.ctx;
            const canvas = gameState.canvas;
            
            // Clear canvas
            ctx.fillStyle = '#0f1527';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.isometricData) {
                ctx.fillStyle = 'white';
                ctx.font = '20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Loading world data...', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Create depth-sorted render layers
            const renderLayers = createDepthSortedLayers();
            
            // Render each layer in depth order (back to front)
            renderLayers.forEach(layer => {
                switch (layer.type) {
                    case 'tile':
                        renderEnhancedTile(layer.object);
                        break;
                    case 'plant':
                        renderEnhancedPlant(layer.object);
                        break;
                    case 'entity':
                        renderEnhancedEntity(layer.object);
                        break;
                    case 'event':
                        renderEnhancedEvent(layer.object);
                        break;
                    case 'geological':
                        renderGeologicalEffect(layer.object);
                        break;
                }
            });
            
            // Render atmospheric effects (weather, etc.)
            renderAtmosphericEffects();
            
            // Render UI overlays
            renderSelectionHighlights();
        }
        
        // Create depth-sorted rendering layers for proper 2.5D visualization
        function createDepthSortedLayers() {
            const layers = [];
            
            // Add tiles with elevation consideration
            gameState.isometricData.tiles.forEach(tile => {
                const depth = calculateDepthSortValue(tile.x, tile.y, tile.elevation);
                layers.push({
                    type: 'tile',
                    object: tile,
                    depth: depth,
                    elevation: tile.elevation
                });
                
                // Add geological events as separate layers
                if (tile.geologicalEvents && tile.geologicalEvents.length > 0) {
                    tile.geologicalEvents.forEach(event => {
                        layers.push({
                            type: 'geological',
                            object: { ...event, x: tile.x, y: tile.y, elevation: tile.elevation },
                            depth: depth - 0.1, // Slightly above tile
                            elevation: tile.elevation
                        });
                    });
                }
            });
            
            // Add plants with their base elevation
            gameState.isometricData.plants.forEach(plant => {
                const baseTile = gameState.isometricData.tiles.find(t => 
                    Math.floor(plant.x) === t.x && Math.floor(plant.y) === t.y);
                const baseElevation = baseTile ? baseTile.elevation : 0;
                const plantElevation = baseElevation + (plant.size * 0.1); // Plants add height
                
                const depth = calculateDepthSortValue(plant.x, plant.y, plantElevation);
                layers.push({
                    type: 'plant',
                    object: { ...plant, baseElevation: baseElevation },
                    depth: depth,
                    elevation: plantElevation
                });
            });
            
            // Add entities with their base elevation
            gameState.isometricData.entities.forEach(entity => {
                const baseTile = gameState.isometricData.tiles.find(t => 
                    Math.floor(entity.x) === t.x && Math.floor(entity.y) === t.y);
                const baseElevation = baseTile ? baseTile.elevation : 0;
                const entityElevation = baseElevation + 0.2; // Entities are above ground
                
                const depth = calculateDepthSortValue(entity.x, entity.y, entityElevation);
                layers.push({
                    type: 'entity',
                    object: { ...entity, baseElevation: baseElevation },
                    depth: depth,
                    elevation: entityElevation
                });
            });
            
            // Add world events at elevated positions
            gameState.isometricData.events.forEach(event => {
                const baseTile = gameState.isometricData.tiles.find(t => 
                    Math.floor(event.x) === t.x && Math.floor(event.y) === t.y);
                const baseElevation = baseTile ? baseTile.elevation : 0;
                const eventElevation = baseElevation + 0.5; // Events float above everything
                
                const depth = calculateDepthSortValue(event.x, event.y, eventElevation);
                layers.push({
                    type: 'event',
                    object: { ...event, baseElevation: baseElevation },
                    depth: depth,
                    elevation: eventElevation
                });
            });
            
            // Sort by depth (higher depth values render first = background)
            layers.sort((a, b) => b.depth - a.depth);
            
            return layers;
        }
        
        // Calculate depth sort value considering both position and elevation
        function calculateDepthSortValue(x, y, elevation) {
            // Isometric depth sorting: items further "back" (higher x+y) render first
            // Items with higher elevation render later (appear in front)
            const isoDepth = x + y;
            const elevationBoost = elevation * 1000; // Elevation takes priority
            return isoDepth - elevationBoost;
        }

        // Convert world coordinates to isometric screen coordinates with elevation support
        function worldToIso(worldX, worldY, elevation = 0) {
            const isoX = (worldX - worldY) * (gameState.tileSize.width / 2);
            const isoY = (worldX + worldY) * (gameState.tileSize.height / 2);
            
            // Apply elevation offset - higher elevation appears higher on screen
            const elevationOffset = elevation * gameState.elevationScale * gameState.zoom;
            
            const screenX = (isoX - gameState.camera.x * gameState.tileSize.width / 2) * gameState.zoom + gameState.canvas.width / 2;
            const screenY = (isoY - gameState.camera.y * gameState.tileSize.height / 2) * gameState.zoom + gameState.canvas.height / 2 - elevationOffset;
            
            return { x: screenX, y: screenY };
        }

        // Convert isometric screen coordinates to world coordinates
        function isoToWorld(screenX, screenY) {
            const isoX = (screenX - gameState.canvas.width / 2) / gameState.zoom + gameState.camera.x * gameState.tileSize.width / 2;
            const isoY = (screenY - gameState.canvas.height / 2) / gameState.zoom + gameState.camera.y * gameState.tileSize.height / 2;
            
            const worldX = (isoX / (gameState.tileSize.width / 2) + isoY / (gameState.tileSize.height / 2)) / 2;
            const worldY = (isoY / (gameState.tileSize.height / 2) - isoX / (gameState.tileSize.width / 2)) / 2;
            
            return { x: worldX, y: worldY };
        }

        // Render a tile
        // Enhanced tile rendering with elevation-based 3D effect
        function renderEnhancedTile(tile) {
            const pos = worldToIso(tile.x, tile.y, tile.elevation);
            const ctx = gameState.ctx;
            
            const tileWidth = gameState.tileSize.width * gameState.zoom;
            const tileHeight = gameState.tileSize.height * gameState.zoom;
            
            // Calculate tile depth based on elevation
            const depthHeight = Math.abs(tile.elevation) * gameState.elevationScale * gameState.zoom * 0.3;
            
            // Draw tile base with depth effect
            if (tile.elevation !== 0) {
                // Draw side faces for elevation effect
                drawTileDepth(pos, tileWidth, tileHeight, depthHeight, tile.elevation, tile.color);
            }
            
            // Draw top diamond face
            ctx.fillStyle = tile.color;
            
            // Adjust color based on elevation (higher = lighter, lower = darker)
            const elevationFactor = (tile.elevation + 1) / 2; // Normalize to 0-1
            const shadedColor = adjustColorBrightness(tile.color, elevationFactor);
            ctx.fillStyle = shadedColor;
            
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y - tileHeight / 2);           // Top
            ctx.lineTo(pos.x + tileWidth / 2, pos.y);            // Right
            ctx.lineTo(pos.x, pos.y + tileHeight / 2);           // Bottom
            ctx.lineTo(pos.x - tileWidth / 2, pos.y);            // Left
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw water surface if present
            if (tile.waterLevel > 0) {
                renderWaterSurface(pos, tileWidth, tileHeight, tile.waterLevel, tile.elevation);
            }
            
            // Draw slope indicators for steep terrain
            if (tile.slope > 0.3) {
                renderSlopeIndicators(pos, tile.slope, tileWidth, tileHeight);
            }
        }
        
        // Draw 3D depth effect for elevated tiles
        function drawTileDepth(pos, tileWidth, tileHeight, depthHeight, elevation, baseColor) {
            const ctx = gameState.ctx;
            
            if (elevation > 0) {
                // Draw right face (darker)
                ctx.fillStyle = adjustColorBrightness(baseColor, 0.7);
                ctx.beginPath();
                ctx.moveTo(pos.x + tileWidth / 2, pos.y);
                ctx.lineTo(pos.x + tileWidth / 2, pos.y + depthHeight);
                ctx.lineTo(pos.x, pos.y + tileHeight / 2 + depthHeight);
                ctx.lineTo(pos.x, pos.y + tileHeight / 2);
                ctx.closePath();
                ctx.fill();
                
                // Draw left face (darkest)
                ctx.fillStyle = adjustColorBrightness(baseColor, 0.5);
                ctx.beginPath();
                ctx.moveTo(pos.x - tileWidth / 2, pos.y);
                ctx.lineTo(pos.x - tileWidth / 2, pos.y + depthHeight);
                ctx.lineTo(pos.x, pos.y + tileHeight / 2 + depthHeight);
                ctx.lineTo(pos.x, pos.y + tileHeight / 2);
                ctx.closePath();
                ctx.fill();
            } else {
                // For negative elevation (valleys), draw depression effect
                ctx.fillStyle = adjustColorBrightness(baseColor, 0.3);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y - tileHeight / 2);
                ctx.lineTo(pos.x + tileWidth / 2, pos.y);
                ctx.lineTo(pos.x, pos.y + tileHeight / 2);
                ctx.lineTo(pos.x - tileWidth / 2, pos.y);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
        }
        
        // Render water surface with transparency and animation
        function renderWaterSurface(pos, tileWidth, tileHeight, waterLevel, baseElevation) {
            const ctx = gameState.ctx;
            const time = Date.now() * 0.001;
            
            // Animate water with subtle wave effect
            const waveOffset = Math.sin(time + pos.x * 0.01 + pos.y * 0.01) * 2;
            const waterY = pos.y - (baseElevation + waterLevel) * gameState.elevationScale * gameState.zoom + waveOffset;
            
            // Water surface
            ctx.fillStyle = `rgba(50, 100, 200, ${Math.min(waterLevel, 0.7)})`;
            ctx.strokeStyle = 'rgba(30, 80, 180, 0.8)';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(pos.x, waterY - tileHeight / 2);
            ctx.lineTo(pos.x + tileWidth / 2, waterY);
            ctx.lineTo(pos.x, waterY + tileHeight / 2);
            ctx.lineTo(pos.x - tileWidth / 2, waterY);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Add water reflection effect
            ctx.fillStyle = `rgba(255, 255, 255, ${waterLevel * 0.1})`;
            ctx.beginPath();
            ctx.moveTo(pos.x, waterY - tileHeight / 4);
            ctx.lineTo(pos.x + tileWidth / 4, waterY);
            ctx.lineTo(pos.x, waterY + tileHeight / 4);
            ctx.lineTo(pos.x - tileWidth / 4, waterY);
            ctx.closePath();
            ctx.fill();
        }
        
        // Render slope indicators for steep terrain
        function renderSlopeIndicators(pos, slope, tileWidth, tileHeight) {
            const ctx = gameState.ctx;
            const intensity = Math.min(slope, 1.0);
            
            ctx.strokeStyle = `rgba(100, 100, 100, ${intensity * 0.5})`;
            ctx.lineWidth = 1;
            
            // Draw slope lines
            const numLines = Math.floor(intensity * 4) + 1;
            for (let i = 0; i < numLines; i++) {
                const offset = (i - numLines / 2) * (tileWidth / numLines) * 0.5;
                ctx.beginPath();
                ctx.moveTo(pos.x + offset, pos.y - tileHeight / 4);
                ctx.lineTo(pos.x + offset, pos.y + tileHeight / 4);
                ctx.stroke();
            }
        }
        
        // Enhanced plant rendering with elevation awareness
        function renderEnhancedPlant(plant) {
            const pos = worldToIso(plant.x, plant.y, plant.baseElevation);
            const ctx = gameState.ctx;
            
            const size = Math.max(3, plant.size * gameState.zoom * 3);
            const plantHeight = plant.size * 10 * gameState.zoom; // Plant height based on size
            const plantTopY = pos.y - plantHeight;
            
            // Draw plant trunk/stem
            if (plant.type === 2) { // Tree
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = Math.max(2, size * 0.3);
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x, plantTopY);
                ctx.stroke();
                
                // Tree canopy
                ctx.fillStyle = plant.color;
                ctx.strokeStyle = 'rgba(0, 100, 0, 0.8)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(pos.x, plantTopY - size / 2, size, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            } else {
                // Other plants (grass, bushes, etc.)
                ctx.fillStyle = plant.color;
                ctx.strokeStyle = 'rgba(0, 100, 0, 0.8)';
                ctx.lineWidth = 1;
                
                if (plant.type === 1) { // Bush
                    // Draw bush as multiple circles
                    const bushSize = size * 0.7;
                    for (let i = 0; i < 3; i++) {
                        const offset = (i - 1) * bushSize * 0.3;
                        ctx.beginPath();
                        ctx.arc(pos.x + offset, pos.y - bushSize + offset * 0.5, bushSize, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                } else {
                    // Grass and other plants
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y - size / 2, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            // Add plant shadow
            renderPlantShadow(pos, size, plant.type);
        }
        
        // Render plant shadow for depth perception
        function renderPlantShadow(pos, size, plantType) {
            const ctx = gameState.ctx;
            const shadowOffset = size * 0.5;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(pos.x + shadowOffset, pos.y + shadowOffset, size * 0.8, size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Enhanced entity rendering with elevation and improved visuals
        function renderEnhancedEntity(entity) {
            const pos = worldToIso(entity.x, entity.y, entity.baseElevation);
            const ctx = gameState.ctx;
            
            const size = Math.max(4, (entity.size + 1) * gameState.zoom * 4);
            const entityHeight = size * 1.5; // Entity height
            const entityY = pos.y - entityHeight / 2;
            
            // Draw entity shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(pos.x + size * 0.3, pos.y + size * 0.3, size * 0.8, size * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw entity body with gradient effect
            const gradient = ctx.createRadialGradient(pos.x, entityY, 0, pos.x, entityY, size);
            gradient.addColorStop(0, entity.color);
            gradient.addColorStop(1, adjustColorBrightness(entity.color, 0.7));
            
            ctx.fillStyle = gradient;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.lineWidth = 1;
            
            // Draw entity shape based on species/traits
            if (entity.traits.flying_ability > 0.5) {
                // Flying entity - draw with wing-like shape
                ctx.beginPath();
                ctx.ellipse(pos.x, entityY, size, size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Wing indicators
                ctx.strokeStyle = adjustColorBrightness(entity.color, 1.2);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pos.x - size, entityY);
                ctx.lineTo(pos.x + size, entityY);
                ctx.stroke();
            } else if (entity.traits.aquatic_adaptation > 0.5) {
                // Aquatic entity - elongated shape
                ctx.beginPath();
                ctx.ellipse(pos.x, entityY, size * 1.2, size * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            } else {
                // Land entity - standard rectangular/circular shape
                ctx.fillRect(pos.x - size / 2, entityY - size / 2, size, size);
                ctx.strokeRect(pos.x - size / 2, entityY - size / 2, size, size);
            }
            
            // Draw entity status indicators
            renderEntityStatusIndicators(pos, entityY, size, entity);
        }
        
        // Render status indicators for entities (energy, health, etc.)
        function renderEntityStatusIndicators(pos, entityY, size, entity) {
            const ctx = gameState.ctx;
            
            // Energy bar
            const barWidth = size;
            const barHeight = 3;
            const energyPercent = Math.max(0, Math.min(1, entity.energy / 100));
            
            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(pos.x - barWidth / 2, entityY - size / 2 - 8, barWidth, barHeight);
            
            // Energy level
            ctx.fillStyle = energyPercent > 0.3 ? '#4CAF50' : '#F44336';
            ctx.fillRect(pos.x - barWidth / 2, entityY - size / 2 - 8, barWidth * energyPercent, barHeight);
        }
        
        // Enhanced event rendering with 3D effects and animations
        function renderEnhancedEvent(event) {
            const pos = worldToIso(event.x, event.y, event.baseElevation);
            const ctx = gameState.ctx;
            
            const alpha = Math.max(0, Math.min(1, event.intensity));
            if (alpha <= 0) return;
            
            const time = Date.now() * 0.001;
            const baseSize = 20;
            const size = baseSize * (1 + event.intensity) * gameState.zoom;
            
            // Animated elevation offset for floating effect
            const floatOffset = Math.sin(time * 2 + event.id) * 5;
            const eventY = pos.y - gameState.elevationScale * gameState.zoom * 0.8 + floatOffset;
            
            // Draw multiple animated layers for enhanced visual effect
            const layers = 3;
            for (let layer = 0; layer < layers; layer++) {
                const layerAlpha = alpha * (0.8 - layer * 0.2);
                const layerSize = size * (1.2 - layer * 0.2);
                const layerOffset = Math.sin(time * (1 + layer * 0.5) + event.id) * (2 + layer);
                
                const color = hexToRgba(event.color, layerAlpha * 0.4);
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(pos.x, eventY + layerOffset, layerSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Main event core
            ctx.fillStyle = hexToRgba(event.color, alpha * 0.8);
            ctx.strokeStyle = event.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pos.x, eventY, size * 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Event type symbol
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `${Math.max(8, size * 0.3)}px monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const symbol = getEventSymbol(event.type);
            ctx.fillText(symbol, pos.x, eventY);
            
            // Particle effects for certain event types
            renderEventParticles(pos.x, eventY, event, size);
        }
        
        // Render geological effects with enhanced animations
        function renderGeologicalEffect(geoEvent) {
            const pos = worldToIso(geoEvent.x, geoEvent.y, geoEvent.elevation);
            const ctx = gameState.ctx;
            const time = Date.now() * 0.001;
            
            const intensity = geoEvent.intensity;
            const alpha = Math.max(0, Math.min(0.8, intensity));
            
            switch (geoEvent.type) {
                case 'earthquake':
                    renderEarthquakeEffect(pos, intensity, alpha, time);
                    break;
                case 'volcanic_eruption':
                    renderVolcanicEruption(pos, intensity, alpha, time);
                    break;
                case 'flood':
                    renderFloodEffect(pos, intensity, alpha, time);
                    break;
                case 'landslide':
                    renderLandslideEffect(pos, intensity, alpha, time);
                    break;
                default:
                    renderGenericGeologicalEffect(pos, intensity, alpha, geoEvent.color);
                    break;
            }
        }
        
        // Render atmospheric effects (weather, general ambiance)
        function renderAtmosphericEffects() {
            // Add subtle ambient effects based on world state
            // This could include weather patterns, day/night effects, etc.
            const ctx = gameState.ctx;
            const time = Date.now() * 0.001;
            
            // Example: subtle fog effect
            const fogAlpha = 0.05 + Math.sin(time * 0.5) * 0.02;
            ctx.fillStyle = `rgba(200, 200, 255, ${fogAlpha})`;
            ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
        }

        // Render an entity
        // Convert hex color to rgba
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Adjust color brightness for shading effects
        function adjustColorBrightness(hex, factor) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            
            const newR = Math.min(255, Math.max(0, Math.floor(r * factor)));
            const newG = Math.min(255, Math.max(0, Math.floor(g * factor)));
            const newB = Math.min(255, Math.max(0, Math.floor(b * factor)));
            
            return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
        }
        
        // Geological effect rendering functions
        function renderEarthquakeEffect(pos, intensity, alpha, time) {
            const ctx = gameState.ctx;
            const shakeX = Math.sin(time * 20) * intensity * 3;
            const shakeY = Math.cos(time * 25) * intensity * 2;
            
            ctx.strokeStyle = `rgba(139, 69, 19, ${alpha})`;
            ctx.lineWidth = Math.max(1, intensity * 3);
            
            // Draw crack lines
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const length = intensity * 20;
                ctx.beginPath();
                ctx.moveTo(pos.x + shakeX, pos.y + shakeY);
                ctx.lineTo(pos.x + Math.cos(angle) * length + shakeX, pos.y + Math.sin(angle) * length + shakeY);
                ctx.stroke();
            }
        }
        
        function renderVolcanicEruption(pos, intensity, alpha, time) {
            const ctx = gameState.ctx;
            
            // Lava particles
            for (let i = 0; i < intensity * 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * intensity * 30;
                const height = Math.sin(time * 2 + i) * intensity * 20;
                
                const x = pos.x + Math.cos(angle) * distance;
                const y = pos.y + Math.sin(angle) * distance - height;
                
                ctx.fillStyle = `rgba(255, ${Math.floor(100 + Math.random() * 100)}, 0, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(x, y, Math.random() * 3 + 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function renderFloodEffect(pos, intensity, alpha, time) {
            const ctx = gameState.ctx;
            const waveOffset = Math.sin(time * 3) * 5;
            
            ctx.fillStyle = `rgba(30, 144, 255, ${alpha * 0.6})`;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y + waveOffset, intensity * 25, 0, Math.PI * 2);
            ctx.fill();
            
            // Water ripples
            for (let i = 1; i <= 3; i++) {
                ctx.strokeStyle = `rgba(30, 144, 255, ${alpha * 0.3 / i})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y + waveOffset, intensity * 25 * i, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        function renderLandslideEffect(pos, intensity, alpha, time) {
            const ctx = gameState.ctx;
            
            // Falling debris
            for (let i = 0; i < intensity * 8; i++) {
                const offsetX = (Math.random() - 0.5) * intensity * 40;
                const fallY = Math.sin(time + i) * intensity * 15;
                
                ctx.fillStyle = `rgba(160, 82, 45, ${alpha * 0.7})`;
                ctx.beginPath();
                ctx.arc(pos.x + offsetX, pos.y + fallY, Math.random() * 2 + 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function renderGenericGeologicalEffect(pos, intensity, alpha, color) {
            const ctx = gameState.ctx;
            
            ctx.fillStyle = hexToRgba(color, alpha * 0.5);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, intensity * 20, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Render particle effects for events
        function renderEventParticles(x, y, event, size) {
            const ctx = gameState.ctx;
            const time = Date.now() * 0.001;
            
            switch (event.type) {
                case 'birth':
                    // Sparkle effect
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2 + time;
                        const distance = Math.sin(time * 3 + i) * size * 0.5;
                        const sparkleX = x + Math.cos(angle) * distance;
                        const sparkleY = y + Math.sin(angle) * distance;
                        
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                    
                case 'death':
                    // Fade particles
                    for (let i = 0; i < 3; i++) {
                        const offsetY = Math.sin(time + i) * 10 - i * 5;
                        ctx.fillStyle = `rgba(128, 128, 128, ${0.5 - i * 0.15})`;
                        ctx.beginPath();
                        ctx.arc(x, y + offsetY, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
            }
        }

        // Get symbol for event type
        function getEventSymbol(eventType) {
            const symbols = {
                'birth': '♪',
                'death': '✝',
                'reproduction': '♥',
                'evolution': '⚡',
                'mutation': '◊',
                'migration': '→',
                'combat': '⚔',
                'cooperation': '☯',
                'tool_creation': '🔨',
                'structure_built': '🏗',
                'extinction': '💀',
                'speciation': '🧬',
                'environmental': '🌍',
                'disaster': '💥',
                'discovery': '💡'
            };
            return symbols[eventType] || '?';
        }

        // Check if position is near mouse cursor
        function isNearMouse(x, y, radius) {
            const dx = gameState.mousePos.x - x;
            const dy = gameState.mousePos.y - y;
            return (dx * dx + dy * dy) < (radius * radius);
        }

        // Draw event tooltip
        function drawEventTooltip(x, y, event) {
            const ctx = gameState.ctx;
            const text = `${event.type}: ${event.description}`;
            
            // Measure text
            ctx.font = '12px monospace';
            const metrics = ctx.measureText(text);
            const padding = 8;
            const width = metrics.width + padding * 2;
            const height = 20;
            
            // Adjust position to keep tooltip on screen
            let tooltipX = x - width / 2;
            let tooltipY = y - height - 5;
            
            if (tooltipX < 0) tooltipX = 0;
            if (tooltipX + width > gameState.canvas.width) tooltipX = gameState.canvas.width - width;
            if (tooltipY < 0) tooltipY = y + 25;
            
            // Draw tooltip background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(tooltipX, tooltipY, width, height);
            
            // Draw tooltip border
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;
            ctx.strokeRect(tooltipX, tooltipY, width, height);
            
            // Draw text
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, tooltipX + padding, tooltipY + height / 2);
        }

        // Render selection highlights
        function renderSelectionHighlights() {
            const ctx = gameState.ctx;
            
            if (gameState.selectedEntity) {
                const pos = worldToIso(gameState.selectedEntity.x, gameState.selectedEntity.y);
                const size = Math.max(4, (gameState.selectedEntity.size + 1) * gameState.zoom * 4);
                const entityY = pos.y - gameState.tileSize.height * gameState.zoom * 0.5 - size / 2;
                
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 3;
                ctx.strokeRect(pos.x - size / 2 - 2, entityY - 2, size + 4, size + 4);
            }
            
            if (gameState.selectedPlant) {
                const pos = worldToIso(gameState.selectedPlant.x, gameState.selectedPlant.y);
                const size = Math.max(3, gameState.selectedPlant.size * gameState.zoom * 3);
                const plantY = pos.y - gameState.tileSize.height * gameState.zoom * 0.3;
                
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pos.x, plantY, size + 2, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Handle key down events
        function handleKeyDown(e) {
            switch (e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    toggleDetails();
                    break;
                case 'r':
                    resetCamera();
                    break;
                case 'p':
                    togglePause();
                    break;
            }
        }

        // Handle mouse click
        function handleMouseClick(e) {
            const rect = gameState.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const worldPos = isoToWorld(mouseX, mouseY);
            selectAtPosition(worldPos.x, worldPos.y);
        }

        // Handle mouse move
        function handleMouseMove(e) {
            const rect = gameState.canvas.getBoundingClientRect();
            gameState.mousePos.x = e.clientX - rect.left;
            gameState.mousePos.y = e.clientY - rect.top;
        }

        // Handle mouse wheel
        function handleMouseWheel(e) {
            e.preventDefault();
            
            const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
            gameState.zoom = Math.max(0.2, Math.min(3.0, gameState.zoom + zoomDelta));
        }

        // Select entity or plant at position
        function selectAtPosition(worldX, worldY) {
            gameState.selectedEntity = null;
            gameState.selectedPlant = null;
            
            if (!gameState.isometricData) return;
            
            // Find closest entity
            let closestEntity = null;
            let closestEntityDist = Infinity;
            
            gameState.isometricData.entities.forEach(entity => {
                const dist = Math.sqrt((entity.x - worldX) ** 2 + (entity.y - worldY) ** 2);
                if (dist < 0.5 && dist < closestEntityDist) {
                    closestEntity = entity;
                    closestEntityDist = dist;
                }
            });
            
            if (closestEntity) {
                gameState.selectedEntity = closestEntity;
                gameState.showDetails = true;
                updateDetailsPanel();
                return;
            }
            
            // Find closest plant
            let closestPlant = null;
            let closestPlantDist = Infinity;
            
            gameState.isometricData.plants.forEach(plant => {
                const dist = Math.sqrt((plant.x - worldX) ** 2 + (plant.y - worldY) ** 2);
                if (dist < 0.5 && dist < closestPlantDist) {
                    closestPlant = plant;
                    closestPlantDist = dist;
                }
            });
            
            if (closestPlant) {
                gameState.selectedPlant = closestPlant;
                gameState.showDetails = true;
                updateDetailsPanel();
            }
        }

        // Update UI elements
        function updateUI() {
            if (!gameState.isometricData) return;
            
            document.getElementById('cameraX').textContent = gameState.camera.x.toFixed(1);
            document.getElementById('cameraY').textContent = gameState.camera.y.toFixed(1);
            document.getElementById('zoomLevel').textContent = gameState.zoom.toFixed(1);
            document.getElementById('entityCount').textContent = gameState.isometricData.entities.length;
            document.getElementById('plantCount').textContent = gameState.isometricData.plants.length;
            document.getElementById('worldTick').textContent = gameState.isometricData.worldInfo.tick;
            document.getElementById('fps').textContent = gameState.fps;
            
            // Update terrain info
            const terrainStats = calculateTerrainStats();
            document.getElementById('terrainInfo').textContent = terrainStats;
            
            // Count geological events
            let geoEventCount = 0;
            gameState.isometricData.tiles.forEach(tile => {
                if (tile.geologicalEvents) {
                    geoEventCount += tile.geologicalEvents.length;
                }
            });
            document.getElementById('geoEvents').textContent = geoEventCount;
        }
        
        // Calculate terrain statistics for UI display
        function calculateTerrainStats() {
            if (!gameState.isometricData || !gameState.isometricData.tiles) {
                return "Loading...";
            }
            
            let minElevation = Infinity;
            let maxElevation = -Infinity;
            let totalElevation = 0;
            let waterTiles = 0;
            
            gameState.isometricData.tiles.forEach(tile => {
                minElevation = Math.min(minElevation, tile.elevation);
                maxElevation = Math.max(maxElevation, tile.elevation);
                totalElevation += tile.elevation;
                if (tile.waterLevel > 0) waterTiles++;
            });
            
            const avgElevation = totalElevation / gameState.isometricData.tiles.length;
            const waterPercent = (waterTiles / gameState.isometricData.tiles.length * 100).toFixed(1);
            
            return `Elev: ${minElevation.toFixed(2)} to ${maxElevation.toFixed(2)} (avg: ${avgElevation.toFixed(2)}) | Water: ${waterPercent}%`;
        }

        // Update details panel
        function updateDetailsPanel() {
            const panel = document.getElementById('detailsPanel');
            const content = document.getElementById('detailsContent');
            
            if (!gameState.showDetails || (!gameState.selectedEntity && !gameState.selectedPlant)) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            
            if (gameState.selectedEntity) {
                content.innerHTML = generateEntityDetails(gameState.selectedEntity);
            } else if (gameState.selectedPlant) {
                content.innerHTML = generatePlantDetails(gameState.selectedPlant);
            }
        }

        // Generate entity details HTML
        function generateEntityDetails(entity) {
            const traitBars = Object.entries(entity.traits)
                .map(([trait, value]) => {
                    const normalizedValue = Math.max(0, Math.min(100, (value + 2) * 25)); // Normalize -2 to 2 range to 0-100
                    const color = getTraitColor(normalizedValue);
                    return `
                        <div class="trait-bar">
                            <div class="trait-name">${trait}:</div>
                            <div class="trait-value">
                                <div class="trait-fill" style="width: ${normalizedValue}%; background: ${color};"></div>
                            </div>
                            <div style="font-size: 10px; width: 40px;">${value.toFixed(2)}</div>
                        </div>
                    `;
                }).join('');
            
            const dnaPreview = entity.dna.genes ? 
                entity.dna.genes.slice(0, 5).map(gene => 
                    `<span style="color: ${gene.active ? '#4CAF50' : '#888'}">${gene.type}:${gene.value.toFixed(2)}</span>`
                ).join(' ') : 'No genes available';
            
            return `
                <div class="entity-details">
                    <h3>🔬 Entity Details</h3>
                    <div><strong>Species:</strong> ${entity.species}</div>
                    <div><strong>ID:</strong> ${entity.id}</div>
                    <div><strong>Size:</strong> ${entity.size.toFixed(2)}</div>
                    <div><strong>Energy:</strong> ${entity.energy.toFixed(1)}</div>
                    <div><strong>Age:</strong> ${entity.age}</div>
                    <div><strong>Position:</strong> (${entity.x.toFixed(1)}, ${entity.y.toFixed(1)})</div>
                    
                    <h4>🧬 Genetic Traits</h4>
                    ${traitBars}
                    
                    <h4>🧬 DNA Information</h4>
                    <div><strong>Total Genes:</strong> ${entity.dna.geneCount}</div>
                    <div><strong>Active Genes:</strong> ${entity.dna.activeGenes}</div>
                    <div class="dna-sequence"><strong>Gene Preview:</strong><br>${dnaPreview}</div>
                </div>
            `;
        }

        // Generate plant details HTML
        function generatePlantDetails(plant) {
            return `
                <div class="plant-details">
                    <h3>🌱 Plant Details</h3>
                    <div><strong>Type:</strong> ${plant.typeName}</div>
                    <div><strong>Size:</strong> ${plant.size.toFixed(2)}</div>
                    <div><strong>Energy:</strong> ${plant.energy.toFixed(1)}</div>
                    <div><strong>Age:</strong> ${plant.age}</div>
                    <div><strong>Alive:</strong> ${plant.isAlive ? 'Yes' : 'No'}</div>
                    <div><strong>Position:</strong> (${plant.x.toFixed(1)}, ${plant.y.toFixed(1)})</div>
                    
                    <h4>🌿 Plant Genetics</h4>
                    <div><strong>Growth Rate:</strong> ${plant.growthRate.toFixed(3)}</div>
                    <div><strong>Reproduction Rate:</strong> ${plant.reproductionRate.toFixed(3)}</div>
                    <div><strong>Max Size:</strong> ${plant.maxSize.toFixed(2)}</div>
                    <div><strong>Disease Resistance:</strong> ${plant.diseaseResistance.toFixed(3)}</div>
                </div>
            `;
        }

        // Get color for trait values
        function getTraitColor(value) {
            if (value < 25) return '#ff4444';
            if (value < 50) return '#ffaa00';
            if (value < 75) return '#ffff00';
            return '#44ff44';
        }

        // Button functions
        function togglePause() {
            gameState.paused = !gameState.paused;
            // Send pause command to server if needed
        }

        function resetCamera() {
            if (gameState.isometricData) {
                gameState.camera.x = gameState.isometricData.worldInfo.width / 2;
                gameState.camera.y = gameState.isometricData.worldInfo.height / 2;
            }
            gameState.zoom = 1.0;
        }

        function toggleDetails() {
            gameState.showDetails = !gameState.showDetails;
            updateDetailsPanel();
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>