<!DOCTYPE html>
<html>
<head>
    <title>EvoSim - 2.5D Isometric View</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            color: white;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #0f1527;
            cursor: pointer;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.4;
            max-width: 300px;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.4;
        }
        
        #detailsPanel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            font-size: 11px;
            line-height: 1.3;
            max-width: 350px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }
        
        .button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .button:hover {
            background: #45a049;
        }
        
        .entity-details {
            border-left: 3px solid #4CAF50;
            padding-left: 10px;
        }
        
        .plant-details {
            border-left: 3px solid #8BC34A;
            padding-left: 10px;
        }
        
        .dna-sequence {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            background: rgba(50, 50, 50, 0.5);
            padding: 5px;
            border-radius: 3px;
            margin: 5px 0;
            word-break: break-all;
        }
        
        .trait-bar {
            display: flex;
            align-items: center;
            margin: 2px 0;
        }
        
        .trait-name {
            width: 100px;
            font-size: 10px;
        }
        
        .trait-value {
            flex: 1;
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin: 0 5px;
            overflow: hidden;
        }
        
        .trait-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading EvoSim...</div>
    
    <canvas id="gameCanvas" width="1024" height="768"></canvas>
    
    <div id="ui">
        <h3>EvoSim 2.5D Isometric View</h3>
        <div>Camera: (<span id="cameraX">0</span>, <span id="cameraY">0</span>)</div>
        <div>Zoom: <span id="zoomLevel">1.0</span>x</div>
        <div>Entities: <span id="entityCount">0</span></div>
        <div>Plants: <span id="plantCount">0</span></div>
        <div>World Tick: <span id="worldTick">0</span></div>
        <div>FPS: <span id="fps">0</span></div>
    </div>
    
    <div id="controls">
        <h4>Controls</h4>
        <div>WASD / Arrow Keys - Move Camera</div>
        <div>Mouse Wheel - Zoom</div>
        <div>Left Click - Select Entity/Plant</div>
        <div>Space - Toggle Details</div>
        <div>R - Reset Camera</div>
        <button class="button" onclick="togglePause()">Pause/Resume</button>
        <button class="button" onclick="resetCamera()">Reset Camera</button>
        <button class="button" onclick="toggleDetails()">Toggle Details</button>
    </div>
    
    <div id="detailsPanel">
        <div id="detailsContent"></div>
    </div>

    <script>
        // Game state
        let gameState = {
            canvas: null,
            ctx: null,
            websocket: null,
            isometricData: null,
            camera: { x: 50, y: 50 },
            zoom: 1.0,
            selectedEntity: null,
            selectedPlant: null,
            showDetails: false,
            paused: false,
            lastUpdate: 0,
            fps: 0,
            frameCount: 0,
            lastFpsUpdate: 0,
            keys: {},
            mousePos: { x: 0, y: 0 },
            tileSize: { width: 64, height: 32 }
        };

        // Initialize the game
        function init() {
            gameState.canvas = document.getElementById('gameCanvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            // Setup event listeners
            setupEventListeners();
            
            // Connect to WebSocket
            connectWebSocket();
            
            // Start game loop
            gameLoop();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
        }

        // Setup event listeners
        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.key.toLowerCase()] = true;
                handleKeyDown(e);
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.key.toLowerCase()] = false;
            });
            
            // Mouse events
            gameState.canvas.addEventListener('click', handleMouseClick);
            gameState.canvas.addEventListener('mousemove', handleMouseMove);
            gameState.canvas.addEventListener('wheel', handleMouseWheel);
            
            // Prevent context menu
            gameState.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        // Connect to WebSocket for real-time data
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            
            gameState.websocket = new WebSocket(wsUrl);
            
            gameState.websocket.onopen = () => {
                console.log('WebSocket connected');
                // Request isometric view data
                requestIsometricData();
            };
            
            gameState.websocket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'isometric') {
                    gameState.isometricData = data.data;
                    updateUI();
                }
            };
            
            gameState.websocket.onclose = () => {
                console.log('WebSocket disconnected, reconnecting...');
                setTimeout(connectWebSocket, 1000);
            };
            
            gameState.websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        // Request isometric data from server
        function requestIsometricData() {
            if (gameState.websocket && gameState.websocket.readyState === WebSocket.OPEN) {
                const request = {
                    type: 'get_isometric_data',
                    viewportX: Math.floor(gameState.camera.x),
                    viewportY: Math.floor(gameState.camera.y),
                    zoom: gameState.zoom,
                    maxTiles: 1000
                };
                gameState.websocket.send(JSON.stringify(request));
            }
        }

        // Main game loop
        function gameLoop() {
            const now = performance.now();
            
            // Update FPS counter
            gameState.frameCount++;
            if (now - gameState.lastFpsUpdate > 1000) {
                gameState.fps = Math.round(gameState.frameCount * 1000 / (now - gameState.lastFpsUpdate));
                gameState.frameCount = 0;
                gameState.lastFpsUpdate = now;
            }
            
            // Update game state
            update(now - gameState.lastUpdate);
            gameState.lastUpdate = now;
            
            // Render
            render();
            
            // Request isometric data periodically
            if (now % 500 < 16) { // Roughly every 500ms
                requestIsometricData();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Update game logic
        function update(deltaTime) {
            const moveSpeed = 2.0 * (deltaTime / 16); // Normalized to 60fps
            
            // Handle camera movement
            if (gameState.keys['w'] || gameState.keys['arrowup']) {
                gameState.camera.y -= moveSpeed / gameState.zoom;
            }
            if (gameState.keys['s'] || gameState.keys['arrowdown']) {
                gameState.camera.y += moveSpeed / gameState.zoom;
            }
            if (gameState.keys['a'] || gameState.keys['arrowleft']) {
                gameState.camera.x -= moveSpeed / gameState.zoom;
            }
            if (gameState.keys['d'] || gameState.keys['arrowright']) {
                gameState.camera.x += moveSpeed / gameState.zoom;
            }
            
            // Clamp camera to world bounds
            if (gameState.isometricData) {
                const worldInfo = gameState.isometricData.worldInfo;
                gameState.camera.x = Math.max(0, Math.min(worldInfo.width, gameState.camera.x));
                gameState.camera.y = Math.max(0, Math.min(worldInfo.height, gameState.camera.y));
            }
        }

        // Render the game
        function render() {
            const ctx = gameState.ctx;
            const canvas = gameState.canvas;
            
            // Clear canvas
            ctx.fillStyle = '#0f1527';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.isometricData) {
                ctx.fillStyle = 'white';
                ctx.font = '20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Loading world data...', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Render tiles
            gameState.isometricData.tiles.forEach(tile => {
                renderTile(tile);
            });
            
            // Render plants
            gameState.isometricData.plants.forEach(plant => {
                renderPlant(plant);
            });
            
            // Render entities
            gameState.isometricData.entities.forEach(entity => {
                renderEntity(entity);
            });
            
            // Render world events
            gameState.isometricData.events.forEach(event => {
                renderEvent(event);
            });
            
            // Render selection highlights
            renderSelectionHighlights();
        }

        // Convert world coordinates to isometric screen coordinates
        function worldToIso(worldX, worldY) {
            const isoX = (worldX - worldY) * (gameState.tileSize.width / 2);
            const isoY = (worldX + worldY) * (gameState.tileSize.height / 2);
            
            const screenX = (isoX - gameState.camera.x * gameState.tileSize.width / 2) * gameState.zoom + gameState.canvas.width / 2;
            const screenY = (isoY - gameState.camera.y * gameState.tileSize.height / 2) * gameState.zoom + gameState.canvas.height / 2;
            
            return { x: screenX, y: screenY };
        }

        // Convert isometric screen coordinates to world coordinates
        function isoToWorld(screenX, screenY) {
            const isoX = (screenX - gameState.canvas.width / 2) / gameState.zoom + gameState.camera.x * gameState.tileSize.width / 2;
            const isoY = (screenY - gameState.canvas.height / 2) / gameState.zoom + gameState.camera.y * gameState.tileSize.height / 2;
            
            const worldX = (isoX / (gameState.tileSize.width / 2) + isoY / (gameState.tileSize.height / 2)) / 2;
            const worldY = (isoY / (gameState.tileSize.height / 2) - isoX / (gameState.tileSize.width / 2)) / 2;
            
            return { x: worldX, y: worldY };
        }

        // Render a tile
        function renderTile(tile) {
            const pos = worldToIso(tile.x, tile.y);
            const ctx = gameState.ctx;
            
            const tileWidth = gameState.tileSize.width * gameState.zoom;
            const tileHeight = gameState.tileSize.height * gameState.zoom;
            
            // Draw diamond shape
            ctx.fillStyle = tile.color;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y - tileHeight / 2);           // Top
            ctx.lineTo(pos.x + tileWidth / 2, pos.y);            // Right
            ctx.lineTo(pos.x, pos.y + tileHeight / 2);           // Bottom
            ctx.lineTo(pos.x - tileWidth / 2, pos.y);            // Left
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }

        // Render a plant
        function renderPlant(plant) {
            const pos = worldToIso(plant.x, plant.y);
            const ctx = gameState.ctx;
            
            const size = Math.max(3, plant.size * gameState.zoom * 3);
            const plantY = pos.y - gameState.tileSize.height * gameState.zoom * 0.3;
            
            // Draw plant as circle
            ctx.fillStyle = plant.color;
            ctx.strokeStyle = 'rgba(0, 100, 0, 0.8)';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.arc(pos.x, plantY, size, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        }

        // Render an entity
        function renderEntity(entity) {
            const pos = worldToIso(entity.x, entity.y);
            const ctx = gameState.ctx;
            
            const size = Math.max(4, (entity.size + 1) * gameState.zoom * 4);
            const entityY = pos.y - gameState.tileSize.height * gameState.zoom * 0.5 - size / 2;
            
            // Draw entity as rectangle
            ctx.fillStyle = entity.color;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.lineWidth = 1;
            
            ctx.fillRect(pos.x - size / 2, entityY, size, size);
            ctx.strokeRect(pos.x - size / 2, entityY, size, size);
        }

        // Render a world event with visual effects
        function renderEvent(event) {
            const pos = worldToIso(event.x, event.y);
            const ctx = gameState.ctx;
            
            // Calculate alpha based on event intensity (fades over time)
            const alpha = event.intensity;
            if (alpha <= 0) return;
            
            // Event visual size based on intensity
            const baseSize = 20;
            const size = baseSize * (1 + event.intensity) * gameState.zoom;
            
            // Event elevation (above everything else)
            const eventY = pos.y - gameState.tileSize.height * gameState.zoom * 0.8;
            
            // Parse color and add alpha
            const color = hexToRgba(event.color, alpha * 0.7);
            const pulseColor = hexToRgba(event.color, alpha * 0.3);
            
            // Draw pulsing effect
            const pulseSize = size * (1 + Math.sin(Date.now() * 0.01) * 0.3);
            ctx.fillStyle = pulseColor;
            ctx.beginPath();
            ctx.arc(pos.x, eventY, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw main event circle
            ctx.fillStyle = color;
            ctx.strokeStyle = event.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pos.x, eventY, size * 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw event type symbol
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `${Math.max(8, size * 0.3)}px monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const symbol = getEventSymbol(event.type);
            ctx.fillText(symbol, pos.x, eventY);
            
            // Draw event description on hover (simplified)
            if (isNearMouse(pos.x, eventY, size)) {
                drawEventTooltip(pos.x, eventY - size - 10, event);
            }
        }

        // Convert hex color to rgba
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Get symbol for event type
        function getEventSymbol(eventType) {
            const symbols = {
                'birth': '♪',
                'death': '✝',
                'reproduction': '♥',
                'evolution': '⚡',
                'mutation': '◊',
                'migration': '→',
                'combat': '⚔',
                'cooperation': '☯',
                'tool_creation': '🔨',
                'structure_built': '🏗',
                'extinction': '💀',
                'speciation': '🧬',
                'environmental': '🌍',
                'disaster': '💥',
                'discovery': '💡'
            };
            return symbols[eventType] || '?';
        }

        // Check if position is near mouse cursor
        function isNearMouse(x, y, radius) {
            const dx = gameState.mousePos.x - x;
            const dy = gameState.mousePos.y - y;
            return (dx * dx + dy * dy) < (radius * radius);
        }

        // Draw event tooltip
        function drawEventTooltip(x, y, event) {
            const ctx = gameState.ctx;
            const text = `${event.type}: ${event.description}`;
            
            // Measure text
            ctx.font = '12px monospace';
            const metrics = ctx.measureText(text);
            const padding = 8;
            const width = metrics.width + padding * 2;
            const height = 20;
            
            // Adjust position to keep tooltip on screen
            let tooltipX = x - width / 2;
            let tooltipY = y - height - 5;
            
            if (tooltipX < 0) tooltipX = 0;
            if (tooltipX + width > gameState.canvas.width) tooltipX = gameState.canvas.width - width;
            if (tooltipY < 0) tooltipY = y + 25;
            
            // Draw tooltip background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(tooltipX, tooltipY, width, height);
            
            // Draw tooltip border
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 1;
            ctx.strokeRect(tooltipX, tooltipY, width, height);
            
            // Draw text
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, tooltipX + padding, tooltipY + height / 2);
        }

        // Render selection highlights
        function renderSelectionHighlights() {
            const ctx = gameState.ctx;
            
            if (gameState.selectedEntity) {
                const pos = worldToIso(gameState.selectedEntity.x, gameState.selectedEntity.y);
                const size = Math.max(4, (gameState.selectedEntity.size + 1) * gameState.zoom * 4);
                const entityY = pos.y - gameState.tileSize.height * gameState.zoom * 0.5 - size / 2;
                
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 3;
                ctx.strokeRect(pos.x - size / 2 - 2, entityY - 2, size + 4, size + 4);
            }
            
            if (gameState.selectedPlant) {
                const pos = worldToIso(gameState.selectedPlant.x, gameState.selectedPlant.y);
                const size = Math.max(3, gameState.selectedPlant.size * gameState.zoom * 3);
                const plantY = pos.y - gameState.tileSize.height * gameState.zoom * 0.3;
                
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pos.x, plantY, size + 2, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // Handle key down events
        function handleKeyDown(e) {
            switch (e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    toggleDetails();
                    break;
                case 'r':
                    resetCamera();
                    break;
                case 'p':
                    togglePause();
                    break;
            }
        }

        // Handle mouse click
        function handleMouseClick(e) {
            const rect = gameState.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const worldPos = isoToWorld(mouseX, mouseY);
            selectAtPosition(worldPos.x, worldPos.y);
        }

        // Handle mouse move
        function handleMouseMove(e) {
            const rect = gameState.canvas.getBoundingClientRect();
            gameState.mousePos.x = e.clientX - rect.left;
            gameState.mousePos.y = e.clientY - rect.top;
        }

        // Handle mouse wheel
        function handleMouseWheel(e) {
            e.preventDefault();
            
            const zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
            gameState.zoom = Math.max(0.2, Math.min(3.0, gameState.zoom + zoomDelta));
        }

        // Select entity or plant at position
        function selectAtPosition(worldX, worldY) {
            gameState.selectedEntity = null;
            gameState.selectedPlant = null;
            
            if (!gameState.isometricData) return;
            
            // Find closest entity
            let closestEntity = null;
            let closestEntityDist = Infinity;
            
            gameState.isometricData.entities.forEach(entity => {
                const dist = Math.sqrt((entity.x - worldX) ** 2 + (entity.y - worldY) ** 2);
                if (dist < 0.5 && dist < closestEntityDist) {
                    closestEntity = entity;
                    closestEntityDist = dist;
                }
            });
            
            if (closestEntity) {
                gameState.selectedEntity = closestEntity;
                gameState.showDetails = true;
                updateDetailsPanel();
                return;
            }
            
            // Find closest plant
            let closestPlant = null;
            let closestPlantDist = Infinity;
            
            gameState.isometricData.plants.forEach(plant => {
                const dist = Math.sqrt((plant.x - worldX) ** 2 + (plant.y - worldY) ** 2);
                if (dist < 0.5 && dist < closestPlantDist) {
                    closestPlant = plant;
                    closestPlantDist = dist;
                }
            });
            
            if (closestPlant) {
                gameState.selectedPlant = closestPlant;
                gameState.showDetails = true;
                updateDetailsPanel();
            }
        }

        // Update UI elements
        function updateUI() {
            if (!gameState.isometricData) return;
            
            document.getElementById('cameraX').textContent = gameState.camera.x.toFixed(1);
            document.getElementById('cameraY').textContent = gameState.camera.y.toFixed(1);
            document.getElementById('zoomLevel').textContent = gameState.zoom.toFixed(1);
            document.getElementById('entityCount').textContent = gameState.isometricData.entities.length;
            document.getElementById('plantCount').textContent = gameState.isometricData.plants.length;
            document.getElementById('worldTick').textContent = gameState.isometricData.worldInfo.tick;
            document.getElementById('fps').textContent = gameState.fps;
        }

        // Update details panel
        function updateDetailsPanel() {
            const panel = document.getElementById('detailsPanel');
            const content = document.getElementById('detailsContent');
            
            if (!gameState.showDetails || (!gameState.selectedEntity && !gameState.selectedPlant)) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            
            if (gameState.selectedEntity) {
                content.innerHTML = generateEntityDetails(gameState.selectedEntity);
            } else if (gameState.selectedPlant) {
                content.innerHTML = generatePlantDetails(gameState.selectedPlant);
            }
        }

        // Generate entity details HTML
        function generateEntityDetails(entity) {
            const traitBars = Object.entries(entity.traits)
                .map(([trait, value]) => {
                    const normalizedValue = Math.max(0, Math.min(100, (value + 2) * 25)); // Normalize -2 to 2 range to 0-100
                    const color = getTraitColor(normalizedValue);
                    return `
                        <div class="trait-bar">
                            <div class="trait-name">${trait}:</div>
                            <div class="trait-value">
                                <div class="trait-fill" style="width: ${normalizedValue}%; background: ${color};"></div>
                            </div>
                            <div style="font-size: 10px; width: 40px;">${value.toFixed(2)}</div>
                        </div>
                    `;
                }).join('');
            
            const dnaPreview = entity.dna.genes ? 
                entity.dna.genes.slice(0, 5).map(gene => 
                    `<span style="color: ${gene.active ? '#4CAF50' : '#888'}">${gene.type}:${gene.value.toFixed(2)}</span>`
                ).join(' ') : 'No genes available';
            
            return `
                <div class="entity-details">
                    <h3>🔬 Entity Details</h3>
                    <div><strong>Species:</strong> ${entity.species}</div>
                    <div><strong>ID:</strong> ${entity.id}</div>
                    <div><strong>Size:</strong> ${entity.size.toFixed(2)}</div>
                    <div><strong>Energy:</strong> ${entity.energy.toFixed(1)}</div>
                    <div><strong>Age:</strong> ${entity.age}</div>
                    <div><strong>Position:</strong> (${entity.x.toFixed(1)}, ${entity.y.toFixed(1)})</div>
                    
                    <h4>🧬 Genetic Traits</h4>
                    ${traitBars}
                    
                    <h4>🧬 DNA Information</h4>
                    <div><strong>Total Genes:</strong> ${entity.dna.geneCount}</div>
                    <div><strong>Active Genes:</strong> ${entity.dna.activeGenes}</div>
                    <div class="dna-sequence"><strong>Gene Preview:</strong><br>${dnaPreview}</div>
                </div>
            `;
        }

        // Generate plant details HTML
        function generatePlantDetails(plant) {
            return `
                <div class="plant-details">
                    <h3>🌱 Plant Details</h3>
                    <div><strong>Type:</strong> ${plant.typeName}</div>
                    <div><strong>Size:</strong> ${plant.size.toFixed(2)}</div>
                    <div><strong>Energy:</strong> ${plant.energy.toFixed(1)}</div>
                    <div><strong>Age:</strong> ${plant.age}</div>
                    <div><strong>Alive:</strong> ${plant.isAlive ? 'Yes' : 'No'}</div>
                    <div><strong>Position:</strong> (${plant.x.toFixed(1)}, ${plant.y.toFixed(1)})</div>
                    
                    <h4>🌿 Plant Genetics</h4>
                    <div><strong>Growth Rate:</strong> ${plant.growthRate.toFixed(3)}</div>
                    <div><strong>Reproduction Rate:</strong> ${plant.reproductionRate.toFixed(3)}</div>
                    <div><strong>Max Size:</strong> ${plant.maxSize.toFixed(2)}</div>
                    <div><strong>Disease Resistance:</strong> ${plant.diseaseResistance.toFixed(3)}</div>
                </div>
            `;
        }

        // Get color for trait values
        function getTraitColor(value) {
            if (value < 25) return '#ff4444';
            if (value < 50) return '#ffaa00';
            if (value < 75) return '#ffff00';
            return '#44ff44';
        }

        // Button functions
        function togglePause() {
            gameState.paused = !gameState.paused;
            // Send pause command to server if needed
        }

        function resetCamera() {
            if (gameState.isometricData) {
                gameState.camera.x = gameState.isometricData.worldInfo.width / 2;
                gameState.camera.y = gameState.isometricData.worldInfo.height / 2;
            }
            gameState.zoom = 1.0;
        }

        function toggleDetails() {
            gameState.showDetails = !gameState.showDetails;
            updateDetailsPanel();
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>